// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.0
// source: pb/worker.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerClient interface {
	TableCheck(ctx context.Context, in *TableCheckArgs, opts ...grpc.CallOption) (*TableCheckReply, error)
	ColumnStatis(ctx context.Context, in *ColumnStatisArgs, opts ...grpc.CallOption) (*ColumnStatisReply, error)
	CBBalance(ctx context.Context, in *BalanceArgs, opts ...grpc.CallOption) (*CBBalanceReply, error)
	RBBalance(ctx context.Context, in *BalanceArgs, opts ...grpc.CallOption) (*RBBalanceReply, error)
	PushCBLP(ctx context.Context, in *PushLPArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PushRBLP(ctx context.Context, in *PushLPArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CBBalanceWorkload(ctx context.Context, in *CBBalanceWorkloadArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RBBalanceWorkload(ctx context.Context, in *RBBalanceWorkloadArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PushCandidates(ctx context.Context, opts ...grpc.CallOption) (Worker_PushCandidatesClient, error)
	PullData(ctx context.Context, in *PullDataArgs, opts ...grpc.CallOption) (Worker_PullDataClient, error)
	CBFilter(ctx context.Context, in *CBFilterArgs, opts ...grpc.CallOption) (*FilterReply, error)
	RBFilter(ctx context.Context, in *RBFilterArgs, opts ...grpc.CallOption) (*FilterReply, error)
	ConflictDetectResult(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConflictDetectResultReply, error)
	CloseService(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BuildClusterIndex(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResultPersist(ctx context.Context, in *ResultPersistArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SinceInferDate(ctx context.Context, in *SinceInferDateArgs, opts ...grpc.CallOption) (*SinceInferDateReply, error)
	SinceInfer(ctx context.Context, in *SinceInferArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AcquireTime(ctx context.Context, in *AcquireTimeArgs, opts ...grpc.CallOption) (*AcquireTimeReply, error)
	RepairInit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RepairBalance(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CBBalanceReply, error)
	RepairBalanceWorkload(ctx context.Context, in *CBBalanceWorkloadArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RepairPushCandidates(ctx context.Context, opts ...grpc.CallOption) (Worker_RepairPushCandidatesClient, error)
	RepairTurn(ctx context.Context, in *Cluster64Message, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RepairVertexCover(ctx context.Context, in *Cluster64Message, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RepairAggr(ctx context.Context, in *RepairAggrArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TableSize(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SizeMessage, error)
	Sampling(ctx context.Context, in *SizeMessage, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type workerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerClient(cc grpc.ClientConnInterface) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) TableCheck(ctx context.Context, in *TableCheckArgs, opts ...grpc.CallOption) (*TableCheckReply, error) {
	out := new(TableCheckReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/TableCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ColumnStatis(ctx context.Context, in *ColumnStatisArgs, opts ...grpc.CallOption) (*ColumnStatisReply, error) {
	out := new(ColumnStatisReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/ColumnStatis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) CBBalance(ctx context.Context, in *BalanceArgs, opts ...grpc.CallOption) (*CBBalanceReply, error) {
	out := new(CBBalanceReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/CBBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RBBalance(ctx context.Context, in *BalanceArgs, opts ...grpc.CallOption) (*RBBalanceReply, error) {
	out := new(RBBalanceReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/RBBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) PushCBLP(ctx context.Context, in *PushLPArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/PushCBLP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) PushRBLP(ctx context.Context, in *PushLPArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/PushRBLP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) CBBalanceWorkload(ctx context.Context, in *CBBalanceWorkloadArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/CBBalanceWorkload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RBBalanceWorkload(ctx context.Context, in *RBBalanceWorkloadArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/RBBalanceWorkload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) PushCandidates(ctx context.Context, opts ...grpc.CallOption) (Worker_PushCandidatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[0], "/pb.Worker/PushCandidates", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerPushCandidatesClient{stream}
	return x, nil
}

type Worker_PushCandidatesClient interface {
	Send(*PushCandidatesArgs) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type workerPushCandidatesClient struct {
	grpc.ClientStream
}

func (x *workerPushCandidatesClient) Send(m *PushCandidatesArgs) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerPushCandidatesClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) PullData(ctx context.Context, in *PullDataArgs, opts ...grpc.CallOption) (Worker_PullDataClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[1], "/pb.Worker/PullData", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerPullDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_PullDataClient interface {
	Recv() (*PullDataReply, error)
	grpc.ClientStream
}

type workerPullDataClient struct {
	grpc.ClientStream
}

func (x *workerPullDataClient) Recv() (*PullDataReply, error) {
	m := new(PullDataReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) CBFilter(ctx context.Context, in *CBFilterArgs, opts ...grpc.CallOption) (*FilterReply, error) {
	out := new(FilterReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/CBFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RBFilter(ctx context.Context, in *RBFilterArgs, opts ...grpc.CallOption) (*FilterReply, error) {
	out := new(FilterReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/RBFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ConflictDetectResult(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConflictDetectResultReply, error) {
	out := new(ConflictDetectResultReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/ConflictDetectResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) CloseService(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/CloseService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) BuildClusterIndex(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/BuildClusterIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ResultPersist(ctx context.Context, in *ResultPersistArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/ResultPersist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) SinceInferDate(ctx context.Context, in *SinceInferDateArgs, opts ...grpc.CallOption) (*SinceInferDateReply, error) {
	out := new(SinceInferDateReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/SinceInferDate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) SinceInfer(ctx context.Context, in *SinceInferArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/SinceInfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) AcquireTime(ctx context.Context, in *AcquireTimeArgs, opts ...grpc.CallOption) (*AcquireTimeReply, error) {
	out := new(AcquireTimeReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/AcquireTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RepairInit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/RepairInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RepairBalance(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CBBalanceReply, error) {
	out := new(CBBalanceReply)
	err := c.cc.Invoke(ctx, "/pb.Worker/RepairBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RepairBalanceWorkload(ctx context.Context, in *CBBalanceWorkloadArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/RepairBalanceWorkload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RepairPushCandidates(ctx context.Context, opts ...grpc.CallOption) (Worker_RepairPushCandidatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[2], "/pb.Worker/RepairPushCandidates", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerRepairPushCandidatesClient{stream}
	return x, nil
}

type Worker_RepairPushCandidatesClient interface {
	Send(*PushCandidatesArgs) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type workerRepairPushCandidatesClient struct {
	grpc.ClientStream
}

func (x *workerRepairPushCandidatesClient) Send(m *PushCandidatesArgs) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerRepairPushCandidatesClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) RepairTurn(ctx context.Context, in *Cluster64Message, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/RepairTurn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RepairVertexCover(ctx context.Context, in *Cluster64Message, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/RepairVertexCover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RepairAggr(ctx context.Context, in *RepairAggrArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/RepairAggr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TableSize(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SizeMessage, error) {
	out := new(SizeMessage)
	err := c.cc.Invoke(ctx, "/pb.Worker/TableSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Sampling(ctx context.Context, in *SizeMessage, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.Worker/Sampling", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServer is the server API for Worker service.
// All implementations must embed UnimplementedWorkerServer
// for forward compatibility
type WorkerServer interface {
	TableCheck(context.Context, *TableCheckArgs) (*TableCheckReply, error)
	ColumnStatis(context.Context, *ColumnStatisArgs) (*ColumnStatisReply, error)
	CBBalance(context.Context, *BalanceArgs) (*CBBalanceReply, error)
	RBBalance(context.Context, *BalanceArgs) (*RBBalanceReply, error)
	PushCBLP(context.Context, *PushLPArgs) (*emptypb.Empty, error)
	PushRBLP(context.Context, *PushLPArgs) (*emptypb.Empty, error)
	CBBalanceWorkload(context.Context, *CBBalanceWorkloadArgs) (*emptypb.Empty, error)
	RBBalanceWorkload(context.Context, *RBBalanceWorkloadArgs) (*emptypb.Empty, error)
	PushCandidates(Worker_PushCandidatesServer) error
	PullData(*PullDataArgs, Worker_PullDataServer) error
	CBFilter(context.Context, *CBFilterArgs) (*FilterReply, error)
	RBFilter(context.Context, *RBFilterArgs) (*FilterReply, error)
	ConflictDetectResult(context.Context, *emptypb.Empty) (*ConflictDetectResultReply, error)
	CloseService(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	BuildClusterIndex(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	ResultPersist(context.Context, *ResultPersistArgs) (*emptypb.Empty, error)
	SinceInferDate(context.Context, *SinceInferDateArgs) (*SinceInferDateReply, error)
	SinceInfer(context.Context, *SinceInferArgs) (*emptypb.Empty, error)
	AcquireTime(context.Context, *AcquireTimeArgs) (*AcquireTimeReply, error)
	RepairInit(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	RepairBalance(context.Context, *emptypb.Empty) (*CBBalanceReply, error)
	RepairBalanceWorkload(context.Context, *CBBalanceWorkloadArgs) (*emptypb.Empty, error)
	RepairPushCandidates(Worker_RepairPushCandidatesServer) error
	RepairTurn(context.Context, *Cluster64Message) (*emptypb.Empty, error)
	RepairVertexCover(context.Context, *Cluster64Message) (*emptypb.Empty, error)
	RepairAggr(context.Context, *RepairAggrArgs) (*emptypb.Empty, error)
	TableSize(context.Context, *emptypb.Empty) (*SizeMessage, error)
	Sampling(context.Context, *SizeMessage) (*emptypb.Empty, error)
	mustEmbedUnimplementedWorkerServer()
}

// UnimplementedWorkerServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerServer struct {
}

func (UnimplementedWorkerServer) TableCheck(context.Context, *TableCheckArgs) (*TableCheckReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableCheck not implemented")
}
func (UnimplementedWorkerServer) ColumnStatis(context.Context, *ColumnStatisArgs) (*ColumnStatisReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ColumnStatis not implemented")
}
func (UnimplementedWorkerServer) CBBalance(context.Context, *BalanceArgs) (*CBBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CBBalance not implemented")
}
func (UnimplementedWorkerServer) RBBalance(context.Context, *BalanceArgs) (*RBBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RBBalance not implemented")
}
func (UnimplementedWorkerServer) PushCBLP(context.Context, *PushLPArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushCBLP not implemented")
}
func (UnimplementedWorkerServer) PushRBLP(context.Context, *PushLPArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushRBLP not implemented")
}
func (UnimplementedWorkerServer) CBBalanceWorkload(context.Context, *CBBalanceWorkloadArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CBBalanceWorkload not implemented")
}
func (UnimplementedWorkerServer) RBBalanceWorkload(context.Context, *RBBalanceWorkloadArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RBBalanceWorkload not implemented")
}
func (UnimplementedWorkerServer) PushCandidates(Worker_PushCandidatesServer) error {
	return status.Errorf(codes.Unimplemented, "method PushCandidates not implemented")
}
func (UnimplementedWorkerServer) PullData(*PullDataArgs, Worker_PullDataServer) error {
	return status.Errorf(codes.Unimplemented, "method PullData not implemented")
}
func (UnimplementedWorkerServer) CBFilter(context.Context, *CBFilterArgs) (*FilterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CBFilter not implemented")
}
func (UnimplementedWorkerServer) RBFilter(context.Context, *RBFilterArgs) (*FilterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RBFilter not implemented")
}
func (UnimplementedWorkerServer) ConflictDetectResult(context.Context, *emptypb.Empty) (*ConflictDetectResultReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConflictDetectResult not implemented")
}
func (UnimplementedWorkerServer) CloseService(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseService not implemented")
}
func (UnimplementedWorkerServer) BuildClusterIndex(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildClusterIndex not implemented")
}
func (UnimplementedWorkerServer) ResultPersist(context.Context, *ResultPersistArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResultPersist not implemented")
}
func (UnimplementedWorkerServer) SinceInferDate(context.Context, *SinceInferDateArgs) (*SinceInferDateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SinceInferDate not implemented")
}
func (UnimplementedWorkerServer) SinceInfer(context.Context, *SinceInferArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SinceInfer not implemented")
}
func (UnimplementedWorkerServer) AcquireTime(context.Context, *AcquireTimeArgs) (*AcquireTimeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcquireTime not implemented")
}
func (UnimplementedWorkerServer) RepairInit(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairInit not implemented")
}
func (UnimplementedWorkerServer) RepairBalance(context.Context, *emptypb.Empty) (*CBBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairBalance not implemented")
}
func (UnimplementedWorkerServer) RepairBalanceWorkload(context.Context, *CBBalanceWorkloadArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairBalanceWorkload not implemented")
}
func (UnimplementedWorkerServer) RepairPushCandidates(Worker_RepairPushCandidatesServer) error {
	return status.Errorf(codes.Unimplemented, "method RepairPushCandidates not implemented")
}
func (UnimplementedWorkerServer) RepairTurn(context.Context, *Cluster64Message) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairTurn not implemented")
}
func (UnimplementedWorkerServer) RepairVertexCover(context.Context, *Cluster64Message) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairVertexCover not implemented")
}
func (UnimplementedWorkerServer) RepairAggr(context.Context, *RepairAggrArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairAggr not implemented")
}
func (UnimplementedWorkerServer) TableSize(context.Context, *emptypb.Empty) (*SizeMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableSize not implemented")
}
func (UnimplementedWorkerServer) Sampling(context.Context, *SizeMessage) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sampling not implemented")
}
func (UnimplementedWorkerServer) mustEmbedUnimplementedWorkerServer() {}

// UnsafeWorkerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServer will
// result in compilation errors.
type UnsafeWorkerServer interface {
	mustEmbedUnimplementedWorkerServer()
}

func RegisterWorkerServer(s grpc.ServiceRegistrar, srv WorkerServer) {
	s.RegisterService(&Worker_ServiceDesc, srv)
}

func _Worker_TableCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableCheckArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).TableCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/TableCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).TableCheck(ctx, req.(*TableCheckArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ColumnStatis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ColumnStatisArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ColumnStatis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/ColumnStatis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ColumnStatis(ctx, req.(*ColumnStatisArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_CBBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).CBBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/CBBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).CBBalance(ctx, req.(*BalanceArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RBBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RBBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RBBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RBBalance(ctx, req.(*BalanceArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_PushCBLP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushLPArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).PushCBLP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/PushCBLP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).PushCBLP(ctx, req.(*PushLPArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_PushRBLP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushLPArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).PushRBLP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/PushRBLP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).PushRBLP(ctx, req.(*PushLPArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_CBBalanceWorkload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CBBalanceWorkloadArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).CBBalanceWorkload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/CBBalanceWorkload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).CBBalanceWorkload(ctx, req.(*CBBalanceWorkloadArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RBBalanceWorkload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RBBalanceWorkloadArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RBBalanceWorkload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RBBalanceWorkload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RBBalanceWorkload(ctx, req.(*RBBalanceWorkloadArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_PushCandidates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).PushCandidates(&workerPushCandidatesServer{stream})
}

type Worker_PushCandidatesServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*PushCandidatesArgs, error)
	grpc.ServerStream
}

type workerPushCandidatesServer struct {
	grpc.ServerStream
}

func (x *workerPushCandidatesServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerPushCandidatesServer) Recv() (*PushCandidatesArgs, error) {
	m := new(PushCandidatesArgs)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_PullData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PullDataArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).PullData(m, &workerPullDataServer{stream})
}

type Worker_PullDataServer interface {
	Send(*PullDataReply) error
	grpc.ServerStream
}

type workerPullDataServer struct {
	grpc.ServerStream
}

func (x *workerPullDataServer) Send(m *PullDataReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_CBFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CBFilterArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).CBFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/CBFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).CBFilter(ctx, req.(*CBFilterArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RBFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RBFilterArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RBFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RBFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RBFilter(ctx, req.(*RBFilterArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ConflictDetectResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ConflictDetectResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/ConflictDetectResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ConflictDetectResult(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_CloseService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).CloseService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/CloseService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).CloseService(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_BuildClusterIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).BuildClusterIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/BuildClusterIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).BuildClusterIndex(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ResultPersist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResultPersistArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ResultPersist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/ResultPersist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ResultPersist(ctx, req.(*ResultPersistArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_SinceInferDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinceInferDateArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).SinceInferDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/SinceInferDate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).SinceInferDate(ctx, req.(*SinceInferDateArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_SinceInfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinceInferArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).SinceInfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/SinceInfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).SinceInfer(ctx, req.(*SinceInferArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_AcquireTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcquireTimeArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).AcquireTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/AcquireTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).AcquireTime(ctx, req.(*AcquireTimeArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RepairInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RepairInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RepairInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RepairInit(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RepairBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RepairBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RepairBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RepairBalance(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RepairBalanceWorkload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CBBalanceWorkloadArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RepairBalanceWorkload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RepairBalanceWorkload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RepairBalanceWorkload(ctx, req.(*CBBalanceWorkloadArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RepairPushCandidates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).RepairPushCandidates(&workerRepairPushCandidatesServer{stream})
}

type Worker_RepairPushCandidatesServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*PushCandidatesArgs, error)
	grpc.ServerStream
}

type workerRepairPushCandidatesServer struct {
	grpc.ServerStream
}

func (x *workerRepairPushCandidatesServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerRepairPushCandidatesServer) Recv() (*PushCandidatesArgs, error) {
	m := new(PushCandidatesArgs)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_RepairTurn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster64Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RepairTurn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RepairTurn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RepairTurn(ctx, req.(*Cluster64Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RepairVertexCover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster64Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RepairVertexCover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RepairVertexCover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RepairVertexCover(ctx, req.(*Cluster64Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RepairAggr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairAggrArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RepairAggr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/RepairAggr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RepairAggr(ctx, req.(*RepairAggrArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TableSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).TableSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/TableSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).TableSize(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Sampling_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SizeMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Sampling(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Sampling",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Sampling(ctx, req.(*SizeMessage))
	}
	return interceptor(ctx, in, info, handler)
}

// Worker_ServiceDesc is the grpc.ServiceDesc for Worker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Worker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TableCheck",
			Handler:    _Worker_TableCheck_Handler,
		},
		{
			MethodName: "ColumnStatis",
			Handler:    _Worker_ColumnStatis_Handler,
		},
		{
			MethodName: "CBBalance",
			Handler:    _Worker_CBBalance_Handler,
		},
		{
			MethodName: "RBBalance",
			Handler:    _Worker_RBBalance_Handler,
		},
		{
			MethodName: "PushCBLP",
			Handler:    _Worker_PushCBLP_Handler,
		},
		{
			MethodName: "PushRBLP",
			Handler:    _Worker_PushRBLP_Handler,
		},
		{
			MethodName: "CBBalanceWorkload",
			Handler:    _Worker_CBBalanceWorkload_Handler,
		},
		{
			MethodName: "RBBalanceWorkload",
			Handler:    _Worker_RBBalanceWorkload_Handler,
		},
		{
			MethodName: "CBFilter",
			Handler:    _Worker_CBFilter_Handler,
		},
		{
			MethodName: "RBFilter",
			Handler:    _Worker_RBFilter_Handler,
		},
		{
			MethodName: "ConflictDetectResult",
			Handler:    _Worker_ConflictDetectResult_Handler,
		},
		{
			MethodName: "CloseService",
			Handler:    _Worker_CloseService_Handler,
		},
		{
			MethodName: "BuildClusterIndex",
			Handler:    _Worker_BuildClusterIndex_Handler,
		},
		{
			MethodName: "ResultPersist",
			Handler:    _Worker_ResultPersist_Handler,
		},
		{
			MethodName: "SinceInferDate",
			Handler:    _Worker_SinceInferDate_Handler,
		},
		{
			MethodName: "SinceInfer",
			Handler:    _Worker_SinceInfer_Handler,
		},
		{
			MethodName: "AcquireTime",
			Handler:    _Worker_AcquireTime_Handler,
		},
		{
			MethodName: "RepairInit",
			Handler:    _Worker_RepairInit_Handler,
		},
		{
			MethodName: "RepairBalance",
			Handler:    _Worker_RepairBalance_Handler,
		},
		{
			MethodName: "RepairBalanceWorkload",
			Handler:    _Worker_RepairBalanceWorkload_Handler,
		},
		{
			MethodName: "RepairTurn",
			Handler:    _Worker_RepairTurn_Handler,
		},
		{
			MethodName: "RepairVertexCover",
			Handler:    _Worker_RepairVertexCover_Handler,
		},
		{
			MethodName: "RepairAggr",
			Handler:    _Worker_RepairAggr_Handler,
		},
		{
			MethodName: "TableSize",
			Handler:    _Worker_TableSize_Handler,
		},
		{
			MethodName: "Sampling",
			Handler:    _Worker_Sampling_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PushCandidates",
			Handler:       _Worker_PushCandidates_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "PullData",
			Handler:       _Worker_PullData_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RepairPushCandidates",
			Handler:       _Worker_RepairPushCandidates_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb/worker.proto",
}
